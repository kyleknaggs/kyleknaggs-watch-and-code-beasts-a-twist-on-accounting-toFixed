<script src="simpletest.js"></script>
<script>
  /*

  Purpose:
  An improvement on rounding for floating point numbers in JavaScript.

  It treats floats more like decimal values than binary.
  It fixes inconsistent precision rounding in JavaScript.
  This inconsistent rounding is evident when dealing with .05 values.
  Some of these values round up, while others round down.

  // Original toFixed() solution in Accounting JS:
  var toFixed = lib.toFixed = function (value, precision) {
    precision = checkPrecision(precision, lib.settings.number.precision);
    var power = Math.pow(10, precision);

    // Multiply up by precision, round accurately, then divide and use native toFixed():
    return (Math.round(lib.unformat(value) * power) / power).toFixed(precision);
  };

  Exponential Notation solution:
  function betterToFixed(value, precision) {
    var exponentialForm = Number(value + 'e' + precision);
    var rounded = Math.round(exponentialForm);
    var finalResult = Number(rounded + 'e-' + precision);

    return finalResult.toFixed(precision);
  }


  Example:
  (0.615).toFixed(2); // "0.61"
  betterToFixed(0.615, 2); // "0.62"

  Function signature:
  betterToFixed(value, precision)

  Arguments:
  value - The number to be rounded.
  precision - The number of decimal places present in the rounded solution.

  Return value:
  A string that contains the rounded number.

  // Potential value arguments:
  // 0
  // Positive Integers: 1, 2,
  // Negative Integers: -1, -2,
  // Strings: '1'
  // Positive Floating Point Numbers: 1.1
  // Negative Floating Point Numbers: -1.1
  // Number with binary rounding issues: 1.005

  // Potential precision arguments:
  // 0
  // Positive Integers: 1, 2
  // Strings: '1'

  */

  // Function Syntax:
  function betterToFixed(value, precision) {
    var string = String(value);
    var positionOfDecimal = string.indexOf(".");
    var length = string.length;
    var numberOfDecimals = 0;

    // If a decimal exists:
    if(positionOfDecimal > 0){
      numberOfDecimals = length - positionOfDecimal - 1;
    }

    // No calculations necessary:
    if(numberOfDecimals === precision){
      return string;
    }

    // Add requested 0's to end of number:
    if(numberOfDecimals < precision){
      var number = Number(string);
      return number.toFixed(precision);
    }

    var numberToRound = Number(string);

    // Reformat number so it can be rounded to nearest whole number:
    if(numberOfDecimals > 1){
      var beforeDecimal = string.slice(0, positionOfDecimal) + string.slice(positionOfDecimal + 1, length - 1);
      var afterDecimal = string.slice(length - 1);
      var modifiedString = beforeDecimal + "." + afterDecimal;
      numberToRound = Number(modifiedString);
    }

    var roundedNumber = Math.round(numberToRound);
    var roundedResult = roundedNumber;

    // If number was reformtted for rounded, move decimal back:
    if(numberOfDecimals > 1){
      var positionsToMove = length - positionOfDecimal - 2;
      roundedResult = roundedNumber / Math.pow(10,positionsToMove);
    }

    // Converts number to string and add decimals where necessary
    var result = roundedResult.toFixed(precision);
    return result;
  }

  // TODO: Add test for negative number
  tests({
    // If no calculations, make sure it handles the value properly:
    "1) If number of decimals in value === precision, it should return String(value).": function () {
      eq(betterToFixed(1, 0), "1");
      eq(betterToFixed(1.5, 1), "1.5");
      eq(betterToFixed(1.55, 2), "1.55");
    },
    // If no calculations, make sure it formats string properly
    "2) If number of decimals in value < precision, it should return the String(number) with precision number of decimal places.": function () {
      eq(betterToFixed(1, 1), "1.0");
      eq(betterToFixed(1.5, 2), "1.50");
      eq(betterToFixed(1.5, 3), "1.500");
      eq(betterToFixed(1.55, 3), "1.550");
      eq(betterToFixed(1.55, 4), "1.5500");
    },
    // If calculations && numberOfDecimals <=1, rounding is not an issue:
    "3) If precision < numberOfDecimals && numberOfDecimals <= 1, it should return a rounded number with precision number of decimal places.": function () {
      eq(betterToFixed(1, 0), "1");
      eq(betterToFixed(1.5, 0), "2");
    },
    // If calculations && numberOfDecimals > 1, rounding is an issue:
    "4) If precision < numberOfDecimals && numberOfDecimals > 1, it should return a rounded number with precision number of decimal places.": function () {
      // Move decimal one spot
      eq(betterToFixed(1.45, 1), "1.5");
      eq(betterToFixed(1.455, 2), "1.46");
      // Move decimal more than one spot
      eq(betterToFixed(1.455, 1), "1.5");
    },
    // Check types
    "5) If either precision or value is a string, it should still round value to precision number of decimal places.": function () {
      fail();
      // var formattedNumber = betterToFixed("1.46", "2");
      // eq(formattedNumber, "1.456");
    },
    // Make sure it handles strange numbers
    "6) If value cannot be accurately stored by JavaScript, it still round as expected.": function () {
      fail();
      // var firstFormattedNumber = betterToFixed(0.615, 2);
      // eq(firstFormattedNumber, "0.62");

      // var secondFormattedNumber = betterToFixed(1.005, 2);
      // eq(secondFormattedNumber, "1.01");

      // var thirdFormattedNumber = betterToFixed(10.235, 2);
      // eq(thirdFormattedNumber, "10.24");
    },
    // Keep consistent with toFixed()
    "7) If precision < 0, it should throw a Range Error.": function () {
      fail();
      // try{
      //   betterToFixed(15, -1);
      // }catch(e){
      //   eq(e.name, "RangeError");
      //   eq(e.message, "toFixed() digits argument must be between 0 and 10");
      // }
    }

  });
</script>