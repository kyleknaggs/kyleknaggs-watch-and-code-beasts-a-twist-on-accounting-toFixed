<script src="simpletest.js"></script>
<script>
  /*

  Purpose:
  An improvement on rounding for floating point numbers in JavaScript.

  It treats floats more like decimal values than binary.
  It fixes inconsistent precision rounding in JavaScript.
  This inconsistent rounding is evident when dealing with .05 values.
  Some of these values round up, while others round down.

  // Original toFixed() solution in Accounting JS:
  var toFixed = lib.toFixed = function (value, precision) {
    precision = checkPrecision(precision, lib.settings.number.precision);
    var power = Math.pow(10, precision);

    // Multiply up by precision, round accurately, then divide and use native toFixed():
    return (Math.round(lib.unformat(value) * power) / power).toFixed(precision);
  };

  Exponential Notation solution:
  function betterToFixed(value, precision) {
    var exponentialForm = Number(value + 'e' + precision);
    var rounded = Math.round(exponentialForm);
    var finalResult = Number(rounded + 'e-' + precision);

    return finalResult.toFixed(precision);
  }


  Example:
  (0.615).toFixed(2); // "0.61"
  betterToFixed(0.615, 2); // "0.62"

  Function signature:
  betterToFixed(value, precision)

  Arguments:
  value - The number to be rounded.
  precision - The number of decimal places present in the rounded solution.

  Return value:
  A string that contains the rounded number.

  // Potential value arguments:
  // 0
  // Positive Integers: 1, 2,
  // Negative Integers: -1, -2,
  // Strings: '1'
  // Positive Floating Point Numbers: 1.1
  // Negative Floating Point Numbers: -1.1
  // Number with binary rounding issues: 1.005

  // Potential precision arguments:
  // 0
  // Positive Integers: 1, 2
  // Strings: '1'

  */

  // Function Syntax:
  function betterToFixed(value, precision) {
    var string = String(value);
    var positionOfDecimal = string.indexOf(".");
    var length = string.length;
    var numberOfDecimals = 0;

    // If a decimal exists:
    if(positionOfDecimal > 0){
      numberOfDecimals = length - positionOfDecimal - 1;
    }

    // Add 0's to end of number:
    if (numberOfDecimals < precision) {
      var number = Number(string);
      return number.toFixed(precision);
    }

    // Do not add or remove decimal places from number:
    if(numberOfDecimals === precision){
      return string;
    }

    var numberToRound = Number(string);

    // Move decimal up:
    if(numberOfDecimals > 1){
      var beforeDecimal = string.slice(0, positionOfDecimal) + string.slice(positionOfDecimal + 1, length - 1);
      var afterDecimal = string.slice(length - 1);
      var modifiedString = beforeDecimal + "." + afterDecimal;
      numberToRound = Number(modifiedString);
    }

    var roundedNumber = Math.round(numberToRound);
    var roundedResult = roundedNumber;

    // Move decimal back:
    if(numberOfDecimals > 1){
      var positionsToMove = length - positionOfDecimal - 2;
      roundedResult = roundedNumber / Math.pow(10,positionsToMove);
    }

    // Convert number to string and format where necessary
    var result = roundedResult.toFixed(precision);
    return result;
  }

  tests({
    // If no calculations, make sure it handles the value properly:
    "1) If number of decimals in value === precision, it should return String(value).": function () {
      eq(betterToFixed(1, 0), "1");
      eq(betterToFixed(1.5, 1), "1.5");
      eq(betterToFixed(1.55, 2), "1.55");
    },
    // If no rounding, make sure it formats string properly
    "2) If number of decimals in value < precision, it should return the String(number) with precision number of decimal places.": function () {
      eq(betterToFixed(1, 1), "1.0");
      eq(betterToFixed(1.5, 2), "1.50");
      eq(betterToFixed(1.5, 3), "1.500");
      eq(betterToFixed(1.55, 3), "1.550");
      eq(betterToFixed(1.55, 4), "1.5500");
    },
    // If rounding && but calculations && numberOfDecimals <=1, rounding is not an issue:
    "3) If precision < numberOfDecimals && numberOfDecimals <= 1, it should return a rounded number with precision number of decimal places.": function () {
      eq(betterToFixed(1, 0), "1");
      eq(betterToFixed(1.5, 0), "2");
    },
    // If rounding && calculations && numberOfDecimals > 1, rounding is an issue:
    "4) If precision < numberOfDecimals && numberOfDecimals > 1, it should return a rounded number with precision number of decimal places.": function () {
      eq(betterToFixed(1.45, 1), "1.5");
      eq(betterToFixed(1.455, 2), "1.46");
      eq(betterToFixed(1.455, 1), "1.5");
      eq(betterToFixed(1.4555, 2), "1.46");
    },
    "5) If value is negative it should round value down as expected when dealing with Math.round().": function () {
      eq(betterToFixed(-1.5, 0), "-1");
      eq(betterToFixed(-1.45, 1), "-1.4");
      eq(betterToFixed(-1.455, 2), "-1.45");
      eq(betterToFixed(-1.4550, 2), "-1.45");
      eq(betterToFixed(-1.4551, 2), "-1.46");
    },
    "6) If precision or value is a string, it should still round value to precision number of decimal places.": function () {
      eq(betterToFixed("1.456", "2"), "1.46");
    },
    // Make sure it handles strange numbers
    "7) If value cannot be accurately stored by JavaScript, it still round as expected.": function () {
      eq(betterToFixed(0.615, 2), "0.62");
      eq(betterToFixed(1.005, 2), "1.01");
      eq(betterToFixed(10.235, 2), "10.24");
    },
    // Keep consistent with toFixed()
    "8) If precision < 0, it should throw a Range Error.": function () {
      fail();
      // try{
      //   betterToFixed(15, -1);
      // }catch(e){
      //   eq(e.name, "RangeError");
      //   eq(e.message, "toFixed() digits argument must be between 0 and 10");
      // }
    }

  });
</script>