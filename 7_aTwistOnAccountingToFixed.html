<script src="simpletest.js"></script>
<script>
  /*

  Purpose:
  An improvement on rounding for floating point numbers in JavaScript.

  It treats floats more like decimal values than binary.
  It fixes inconsistent precision rounding in JavaScript.
  This inconsistent rounding is evident when dealing with .05 values.
  Some of these values round up, while others round down.

  // Original toFixed() solution in Accounting JS:
  var toFixed = lib.toFixed = function (value, precision) {
    precision = checkPrecision(precision, lib.settings.number.precision);
    var power = Math.pow(10, precision);

    // Multiply up by precision, round accurately, then divide and use native toFixed():
    return (Math.round(lib.unformat(value) * power) / power).toFixed(precision);
  };

  Exponential Notation solution:
  function betterToFixed(value, precision) {
    var exponentialForm = Number(value + 'e' + precision);
    var rounded = Math.round(exponentialForm);
    var finalResult = Number(rounded + 'e-' + precision);

    return finalResult.toFixed(precision);
  }


  Example:
  (0.615).toFixed(2); // "0.61"
  betterToFixed(0.615, 2); // "0.62"

  Function signature:
  betterToFixed(value, precision)

  Arguments:
  value - The number to be rounded.
  precision - The number of decimal places present in the rounded solution.

  Return value:
  A string that contains the rounded number.

  */

  // Function Syntax:
  function betterToFixed(value, precision) {
    // Convert arguments to expected types to avoid potential type conversion issues
    var original = String(value);
    var precisionNumber = Number(precision);
    var indexOfDecimalInOriginal = original.indexOf(".");
    var decimalsInOriginal = 0;

    // Will be -1 if decimal does not exist:
    if(indexOfDecimalInOriginal > 0){
      decimalsInOriginal = original.length - indexOfDecimalInOriginal - 1;
    }

    var beforePadding = original;
    var numberOfZerosToPad = precision - decimalsInOriginal;

    // Perform calculations:
    if(decimalsInOriginal > precision){
      var toRound = Number(original);

      // Move decimal up:
      if (decimalsInOriginal > 1) {
        var indexOfDecimalInStringToRound = indexOfDecimalInOriginal + precisionNumber + 1;
        var beforeDecimal =
          original.slice(0, indexOfDecimalInOriginal)
          + original.slice(indexOfDecimalInOriginal + 1, indexOfDecimalInStringToRound);
        var afterDecimal = original.slice(indexOfDecimalInStringToRound);
        var stringToRound = beforeDecimal + "." + afterDecimal;
        toRound = Number(stringToRound);
      }

      // Round:
      var rounded = Math.round(toRound);
      var roundedResult = rounded;

      // Move decimal back:
      if (decimalsInOriginal > 1) {
        roundedResult = rounded / Math.pow(10, precisionNumber);
      }

      beforePadding = String(roundedResult);

      // Calculate numbersOfZeroToPad:
      var indexOfDecimalInBeforePadding = beforePadding.indexOf('.');
      var decimalsInBeforePadding = 0;

      // Will be -1 if decimal does not exist:
      if(indexOfDecimalInBeforePadding > 0){
        decimalsInBeforePadding = beforePadding.length - indexOfDecimalInBeforePadding - 1;
      }

      numberOfZerosToPad = precision - decimalsInBeforePadding;

    }

    // Pad string if necessary:
    var zerosToPad = [];

    for (var i = 0; i < numberOfZerosToPad; i++) {
      zerosToPad[i] = '0';
    }

    return beforePadding + zerosToPad.join('');

  }

  tests({
    // Option 1: If numberOfDecimals === precisionNumber:
    "1) If numberOfDecimals === precision, it should return String(value).": function () {
      eq(betterToFixed(1.5, 1), "1.5");
    },
    // Option 2: If numberOfDecimals < precisionNumber:
    "2) If numberOfDecimals < precision, it should return String(value) and pad end of result with 0's when necessary.": function () {
      eq(betterToFixed(1.5, 2), "1.50");
    },
    // Option 3: If numberOfDecimals > precisionNumber:
    // Do not manipulate string:
    "3) If numberOfDecimals === 1, it should round as expected.": function () {
      eq(betterToFixed(1.5, 0), "2");
    },
    // Manipulate string.
    "4a) If numberOfDecimals > 1 && (numberOfDecimals - precision) === 1, it should rounded as expected.": function () {
      eq(betterToFixed(1.55, 1), "1.6");
    },
    "4b) If numberOfDecimals > 1 && (numberOfDecimals - precision) === 2, it should rounded as expected.": function () {
      eq(betterToFixed(1.554, 1), "1.6");
    },
    "4c) If numberOfDecimals > 1 && (numberOfDecimals - precision) > 2, it should rounded as expected.": function () {
      eq(betterToFixed(1.5554, 1), "1.6");
    },
    // Format value after rounding:
    "5a) If number of decimals in roundedResult < precision, it should pad end of result with 0's when necessary.": function () {
      eq(betterToFixed(1.501, 2), "1.50");
    },
    // No consensues found on how to handle rounding of negative multiples of 0.5 e.g. -1.5 ==> -1, -1.55 ==> -1.5, -1.555 ==> -1.55
    // Rounding values down keeps function behaviour consistent with Math.round(). e.g. Math.round(-1.5) ==> -1
    "6a) If value is negative, (precision - numberOfDecimals) === 1 && value of decimal passed to Math.round() === 0.5 it should round value down.": function () {
      eq(betterToFixed(-1.5, 0), "-1");
    },
    "6b) If value is negative, (precision - numberOfDecimals) > 1 && value of decimal passed to Math.round() > 0.5, it should round value up.": function () {
      eq(betterToFixed(-1.5554, 2), "-1.56");
    },
    "7) If precision or value is a string, it should still round as expected.": function () {
      eq(betterToFixed("1.555", "2"), "1.56");
    },
    // The entire point of rewriting the toFixed() method.
    "8) It should fix errors when rounding numbers that cannot be accurately stored by JavaScript.": function () {
      eq(betterToFixed(0.615, 2), "0.62");
      eq(betterToFixed(1.005, 2), "1.01");
      eq(betterToFixed(10.235, 2), "10.24");
    }
  });
</script>