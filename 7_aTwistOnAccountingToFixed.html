<script src="simpletest.js"></script>
<script>
  /*

  Purpose:
  An improvement on rounding for floating point numbers in JavaScript.

  It treats floats more like decimal values than binary.
  It fixes inconsistent precision rounding in JavaScript.
  This inconsistent rounding is evident when dealing with .05 values.
  Some of these values round up, while others round down.

  // Original toFixed() solution in Accounting JS:
  var toFixed = lib.toFixed = function (value, precision) {
    precision = checkPrecision(precision, lib.settings.number.precision);
    var power = Math.pow(10, precision);

    // Multiply up by precision, round accurately, then divide and use native toFixed():
    return (Math.round(lib.unformat(value) * power) / power).toFixed(precision);
  };

  Exponential Notation solution:
  function betterToFixed(value, precision) {
    var exponentialForm = Number(value + 'e' + precision);
    var rounded = Math.round(exponentialForm);
    var finalResult = Number(rounded + 'e-' + precision);

    return finalResult.toFixed(precision);
  }


  Example:
  (0.615).toFixed(2); // "0.61"
  betterToFixed(0.615, 2); // "0.62"

  Function signature:
  betterToFixed(value, precision)

  Arguments:
  value - The number to be rounded.
  precision - The number of decimal places present in the rounded solution.

  Return value:
  A string that contains the rounded number.

  */

  // Function Syntax:
  function betterToFixed(value, precision) {
    // Convert argumets to expected types to avoid potential type conversion issues
    var string = String(value);
    var precisionNumber = Number(precision);
    var indexOfDecimal = string.indexOf(".");
    var numberOfDecimals = 0;

    // Will be -1 if decimal does not exist
    if(indexOfDecimal > 0){
      numberOfDecimals = string.length - indexOfDecimal - 1;
    }

    // Option 1: Do not format string.
    if (numberOfDecimals === precisionNumber) {
      return string;
    }

    // Option 2: Format string.
    if (numberOfDecimals < precisionNumber) {
      var number = Number(string);
      return number.toFixed(precisionNumber);
    }

    // Option 3: Round number then format string.
    var numberToRound = Number(string);

    // Move decimal up:
    if(numberOfDecimals > 1){
      var indexAfterModifiedDecimal = indexOfDecimal + precisionNumber + 1;
      var beforeDecimal =
        string.slice(0, indexOfDecimal)
        + string.slice(indexOfDecimal + 1, indexAfterModifiedDecimal);
      var afterDecimal = string.slice(indexAfterModifiedDecimal);
      var stringToRound = beforeDecimal + "." + afterDecimal;
      numberToRound = Number(stringToRound);
    }

    var roundedNumber = Math.round(numberToRound);
    var roundedResult = roundedNumber;

    // Move decimal back:
    if(numberOfDecimals > 1){
      roundedResult = roundedNumber / Math.pow(10, precisionNumber);
    }

    // Convert to string and add 0's where necessary:
    // Be careful, can conceal unexpected rounding issues.
    return roundedResult.toFixed(precisionNumber);
  }

  tests({
    // Option 1: If numberOfDecimals === precision:
    "1) If numberOfDecimals === precision, it should return String(value).": function () {
      eq(betterToFixed(1.5, 1), "1.5");
    },
    // Option 2: If numberOfDecimals < precision:
    "2) If numberOfDecimals < precision, it should return String(number) with precision number of decimal places.": function () {
      eq(betterToFixed(1.5, 2), "1.50");
    },
    // Option 3: If precision < numberOfDecimals:
    "3) If numberOfDecimals === 1, it should return a rounded number with precision number of decimal places.": function () {
      eq(betterToFixed(1.5, 0), "2");
    },
    "4a) If numberOfDecimals > 1, && (numberOfDecimals - precision) === 1, it should return a rounded number with precision number of decimal places.": function () {
      eq(betterToFixed(1.55, 1), "1.6");
    },
    // If (numberOfDecimals - precision) >= 2 and rounding is not handled properly, toFixed() can conceal internal rounding issues:
    "4b) If numberOfDecimals > 1, && (numberOfDecimals - precision) === 2, it should return a rounded number with precision number of decimal places.": function () {
      eq(betterToFixed(1.554, 1), "1.6");
    },
    "4c) If numberOfDecimals > 1, && (numberOfDecimals - precision) > 2, it should return a rounded number with precision number of decimal places.": function () {
      eq(betterToFixed(1.5554, 1), "1.6");
    },
    "5a) If number of decimals in roundedResult < precision, it should add add 0's to the end of roundedResult": function () {
      eq(betterToFixed(1.501, 2), "1.50");
    },
    // No consensues found on how to handle rounding of negative multiples of 0.5 e.g. -1.5 ==> -1, -1.55 ==> -1.5, -1.555 ==> -1.55
    // Rounding values down keeps function behaviour consistent with Math.round(). e.g. Math.round(-1.5) ==> -1
    "6a) If value is negative, precision - numberOfDecimals === 1,  && last digit is 5 it should round value down to keep consistent with Math.round().": function () {
      eq(betterToFixed(-1.55, 1), "-1.5");
    },
    "6b) If value is negative, precision - numberOfDecimals > 1, && decimal of numberToRound > 0.5, it should round value up.": function () {
      eq(betterToFixed(-1.5554, 2), "-1.56");
    },
    "7) If precision or value is a string, it should still round value to precision number of decimal places.": function () {
      eq(betterToFixed("1.555", "2"), "1.56");
    },
    // The entire point of rewriting the toFixed() method.
    "8) If value cannot be accurately stored by JavaScript, it still round as expected.": function () {
      eq(betterToFixed(0.615, 2), "0.62");
      eq(betterToFixed(1.005, 2), "1.01");
      eq(betterToFixed(10.235, 2), "10.24");
    }
  });
</script>